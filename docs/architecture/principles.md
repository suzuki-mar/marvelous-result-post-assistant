# WebSustainMVC 基本方針

> 本書は **WebSustainMVC** の「変わらない原則」をまとめた **基本方針** ドキュメントである。具体的な実装手順・ツール設定・インフラ採用理由はここでは扱わない（実装ガイド／インフラガイドを参照）。本書は、分割前の `architecture.md` の内容を踏まえつつ、原則面を 5000 文字超で再整理したもの。

---

## 1. 目的と位置づけ

**WebSustainMVC** は、次の一方向責務フローを核に据えるアプリケーション設計流儀である。

```
View (app) → Action (server) → UseCase → Domain → Presentation Model → View
                      ↑                   ↘
                   Infra 注入          Read 整形（PM）
```

- **目的**：通信や API 設計を “先に” 考えなくても作れる環境をつくること。UI 操作からビジネスロジックまでが **同一ランタイム内の関数呼び出し**で連なるようにし、責務を**構造**として固定する。これにより、個人〜小規模開発でありがちな「通信境界から設計が崩れる」を防ぐ。
- **適用範囲**：Next.js を前提とした Web アプリケーション。サーバ常駐の Node ランタイム上で Server Action / Route Handler が動く構造を前提にする（ただし具体のベンダや製品名は本書の対象外）。
- **非目標**：マイクロサービス分割やメッセージング網の設計は本流にしない。高トラフィック分散を主眼とする構造や、RPC/REST の API 設計自体を成果物とする開発は対象外。

---

## 2. 設計哲学（変わらない原則）

### 2.1 通信を設計しない

- 責務は **プロセス内**で閉じることを第一に考える。UI → Action → UseCase → Domain の鎖は HTTP を横切らない。
- 「API をどう切るか」ではなく、「**責務をどう切るか**」に集中する。外部連携は **infra** に隔離され、アプリの骨格を揺らさない。

### 2.2 Server Action 前提の一方向性

- UI から最初に触れる関門は **Action**（サーバ側関数）である。Action は UseCase に委譲し、UseCase は Domain を操作する。**逆方向の参照**やショートカット（UI から infra 直参照等）は禁止。
- 依存の**向き**は固定する： `app → actions → usecases → domain`（infra は domain 抽象への実装注入で逆流しない）。

### 2.3 PM（Presentation Model）完結主義

- **UI ロジックは PM に集約**する。表示値の整形、可否判定、ボタン活性、エラーメッセージ等は JSX ではなく PM が担う。
- 1画面=1PM を原則とし、継承は使わず **コンポジション**で分割・再利用する。
- PM は I/O を持たない。UseCase の結果を受け取り、**画面にとって最適な読み取り表現**へ整形する。

### 2.4 ドメイン純度と抽象境界

- Entity / ValueObject / DomainService は **技術非依存**であること。永続化や外部 API の具体は知らない。
- Repository は **抽象**のみを Domain に置く。具体は infra に閉じる（依存反転）。

### 2.5 CQRSES-Light（自然な Command/Read 分離）

- 書き込み（Command）は UseCase 主導。読み取り（Read）は PM が画面都合で整形。**別プロセスや別 DB を要求しない**軽量な分離思想。

### 2.6 設計の尺度は「速度ではなく、構造の安定」

- 一時的なベンチマーク値よりも、**境界が壊れないこと**を優先する。速度改善は境界を守ったまま行う。

---

## 3. 責務構造（層の役割）

| 層                   | 役割                 | できること                            | できないこと                            |
| -------------------- | -------------------- | ------------------------------------- | --------------------------------------- |
| **app(View)**        | 描画専念             | PM の状態を受け取って表示             | ビジネス分岐、外部 I/O、Repository 参照 |
| **actions**          | UI→UseCase の入口    | 入力の基本検査、UseCase 呼び出し      | Domain 操作、外部 I/O 直接実行          |
| **usecases**         | トランザクション境界 | Domain を動かし結果を PM に渡す材料へ | 画面整形、UI 状態制御、技術具象の直参照 |
| **domain**           | 不変条件・意味の中心 | Entity/VO の整合、ルール              | DB 操作、HTTP、SDK 直参照               |
| **presentation(PM)** | 表示と操作の整形     | 文言・表示可否・軽量検証              | 外部 I/O、永続化、SDK 直参照            |
| **infra**            | 技術の封じ込め       | 具象 Repo / API クライアント          | 上位層への依存、UI ロジック             |

**注意**：上位層ほど「知らないこと」が多いほどよい。知らないこと＝変更に強いこと。

---

## 4. バリデーションの思想（責務別の多層防御）

分割前ドキュメントの方針を継承しつつ、目的ごとに責務を固定する。

1. **PM（UI 即時検証）**：入力の必須・形式・最小限の整合。UX 最優先。Zod 等の軽量検証を想定。
2. **Domain（意味・状態の整合）**：`start <= end`、遷移条件、ビジネスルール。Entity/VO 内のガードで常に真に。
3. **保存直前（重い検証）**：一意制約/存在確認/競合検知など、Repository を参照する検証は保存前に集中。
4. **Infra（物理制約）**：DB スキーマ制約・ユニーク・NOT NULL。アプリ側の見落としを最終的に止める。

この「四層」は**重ねがけ**であり、同じチェックを重複してもよい。UX／意味／永続化、それぞれの目的が違うからである。

---

## 5. Server Action の意味づけ

- Action は **唯一の UI 境界**。ここから先は UI の都合ではなく **アプリケーション都合**で動く世界。
- Action 自体は**薄く保つ**。入力の最低限の正当性を確認し、UseCase に委譲する。
- 例外は **ドメイン由来の型**で表現し、UI まで翻訳・還元できるようにする（翻訳は PM 側の責務）。

---

## 6. PM（Presentation Model）の原則

- **状態オブジェクト**であり、画面体験のためのロジックを保持する。Setter を経由した更新で副作用を一箇所に集約する。
- PM は **永続化対象ではない**。セッション継続の必要があれば、必要最小限のスナップショットのみを保持する（保持場所の選択は実装側の課題）。
- **テスト容易性**：PM の単体テストで、表示可否や文言生成を確定できる。UI テストは PM 契約をなぞるだけにする。

---

## 7. 認証の基本方針

- 認証は「通信手段」ではなく **責務**。アプリの外側の技術（OIDC など）は infra に閉じる。
- 上位層が知るのは **「現在の認証済みユーザー」** だけ。これを抽象化し、UseCase/Domain は実装の差を知らない。
- Action は「**認証済みコンテキストの入口**」。以降の層で認証状態を意識させない。

---

## 8. エラーと整合性の方針

- **ドメインエラー**は型で定義し、UseCase で意味を失わないまま扱う。UI では PM が文言へ翻訳する。
- **整合性**は「最小の同期 + 最小の期待」によって守る。保存直前検証と物理制約で確実に落とし、ユーザには PM を通じて分かりやすく返す。
- 楽観的 UI 更新を行う場合も、**真実は Domain/Infra 側**にあると捉え、反映失敗時の戻し戦略を PM で規定する。

---

## 9. トランザクションと副作用

- トランザクション境界は **UseCase 単位**で設計する。外部サービス連携は極力 2 相に寄せ、**副作用の順序**を明確化する。
- Domain は**副作用を持たない**。副作用は UseCase で orchestration として扱う。

---

## 10. 変更容易性のための約束

- **上位層ほど書き換えコストが安い**構造にする。UI/PM は変えやすく、Domain は変えにくい。変更は上から吸収する。
- **抽象から書く**：Domain の契約（Entity/VO/Repository 抽象）を先に固め、実装は後から注入できるようにする。
- **構造の自動検証**：Import の境界は静的ルールで機械監視（詳細は実装ガイド）。人の注意力に依存しない。

---

## 11. 品質基準（方針レベル）

- **読みやすさ＞短さ**：層を跨ぐショートカットや早すぎる抽象化は禁物。層の責務が読み取れることを優先。
- **テスト可能性**：PM / Domain は純度高く、ユニットテストで完結できる。UseCase は結合テストで確性を得る。
- **観測可能性**：ログは層ごとに語彙を変えない。Action・UseCase・Domain で「何が起きたか」が連続して読める。
- **アクセシビリティ**：PM が表示可否を制御できるように定義し、UI は ARIA 等を実装側で担保する。方針として、**動作は PM、表現は UI** の役割分担を守る。

---

## 12. パフォーマンスの考え方

- まず **正しい境界**。最適化はその後。PM での整形・キャッシュは許容するが、副作用や I/O を PM に落とし込んではならない。
- 読み取りの最適化は PM の責務範囲で完結させる（CQRSES-Light）。書き込み経路に最適化を持ち込まない。

---

## 13. ドキュメンテーション連携

- **基本方針**：変えない。レビューでのみ更新。ADR と紐づけ、理由の履歴を残す。
- **実装ガイド**：日々の運用で随時更新。具体例・ディレクトリ・命名・ルールの自動検証方法を記す。
- **インフラガイド**：採用基盤やランタイム前提、セキュリティ・運用方針を記す。基本方針はここから独立している。

---

## 14. 反パターン（やってはいけないこと）

1. **UI がドメインを直参照**：PM を迂回して JSX に分岐・整形が侵入する。→ すべて PM に戻す。
2. **UseCase が infra に直接依存**：抽象を飛び越え具象を掴む。→ 依存反転で注入。
3. **Domain が SDK を知る**：技術語彙がドメイン語彙を汚染。→ 抽象だけにする。
4. **Action の肥大化**：UI 都合の枝刈りや条件分岐が Action に増える。→ UseCase / PM に移譲。
5. **検証の一層化**：どこか 1 箇所だけで全部検証しようとする。→ 四層防御で目的ごとに分担。
6. **テストを UI だけで代替**：PM/Domain の純度を活かさない。

_（この節以降の詳細は実装ガイド／インフラガイドに委ねる）_
